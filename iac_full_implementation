{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "0fa65dcf",
   "metadata": {},
   "source": [
    "# Implementation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 92,
   "id": "8e1a4392",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-12-06T20:48:38.787207Z",
     "start_time": "2024-12-06T20:48:38.777217Z"
    }
   },
   "outputs": [],
   "source": [
    "### Packages\n",
    "\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import panel as pn\n",
    "import networkx as nx\n",
    "import plotly.graph_objs as go\n",
    "import plotly.express as px\n",
    "import json\n",
    "import random\n",
    "\n",
    "import ipywidgets as widgets\n",
    "from IPython.display import display\n",
    "\n",
    "import socket\n",
    "\n",
    "import dash\n",
    "from dash import dcc, html\n",
    "from dash.dependencies import Input, Output, State\n",
    "\n",
    "from itertools import combinations\n",
    "import subprocess\n",
    "\n",
    "col_pal = px.colors.qualitative.Plotly"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 93,
   "id": "7d76b15a",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-12-06T20:48:40.234230Z",
     "start_time": "2024-12-06T20:48:40.212739Z"
    }
   },
   "outputs": [],
   "source": [
    "### Model Logic\n",
    "\n",
    "def get_activation(graph, rest_act=-0.1):\n",
    "    # Change node size based on activation (sum of connection weights), default activation = -0.1\n",
    "    activations = {node: rest_act for node in graph.nodes()}\n",
    "    for u, v, d in graph.edges(data=True):\n",
    "        activations[u] += d[\"weight\"]\n",
    "        if u != v:\n",
    "            activations[v] += d[\"weight\"]\n",
    "    return activations, rest_act\n",
    "\n",
    "def activation_to_size(act, low_bound=20, high_bound=50):\n",
    "     # Maps activation values to visual node sizes (e.g., between 20 and 50), else 35 if equal\n",
    "    max_act = max(act.values())\n",
    "    min_act = min(act.values())\n",
    "    if max_act == min_act:\n",
    "        return (low_bound + high_bound)//2\n",
    "    dynam_sizes = [low_bound + (x-min_act) * (high_bound-low_bound)/(max_act-min_act)\n",
    "                   for x in act.values()]\n",
    "    return dynam_sizes\n",
    "\n",
    "def connection_to_lw(edges, low_bound=0.5, high_bound=2):\n",
    "    # Map connection weights to thinner line widths. Minimum line width 0.5 for thinner lines or 2 for thicker\n",
    "    connections = [np.abs(d['weight']) for _, _, d in edges]\n",
    "    min_con = min(connections) if connections else 0\n",
    "    max_con = max(connections) if connections else 1\n",
    "    if min_con == max_con:\n",
    "        return [(low_bound + high_bound) / 2] * len(edges)\n",
    "    return [\n",
    "        low_bound + (x - min_con) * (high_bound - low_bound) / (max_con - min_con)\n",
    "        for x in connections\n",
    "    ]\n",
    "\n",
    "\"\"\"\n",
    "def connection_to_lw(edges, low_bound=1, high_bound=5):\n",
    "    # Maps connection strengths to linewidths (e.g., between 1 and 5), else 2 if equal\n",
    "    connections = [np.abs(d['weight']) for u, v, d in edges]\n",
    "    min_con = min(connections)\n",
    "    max_con = max(connections)\n",
    "    if min_con == max_con:\n",
    "        return [(low_bound + high_bound)//2]*len(edges)\n",
    "    dynam_lw = [low_bound + (x-min_con) * (high_bound-low_bound)/(max_con-min_con) \n",
    "                for x in connections]\n",
    "    return dynam_lw\n",
    "\"\"\" \n",
    "\n",
    "def position_nodes(pools):\n",
    "    # Arrange nodes in concentric circles based on their pool assignments for network visualization\n",
    "    pos = {}\n",
    "    nodes = list(pools.keys())\n",
    "    pool_ids = list(pools.values())\n",
    "    pool_lens = {str(p): int(c) for p, c in zip(*np.unique(pool_ids, return_counts=True))}\n",
    "\n",
    "    interval = 800  # distance between nodes in each ring\n",
    "    center_coord = (0, 0)  # center of all rings\n",
    "    radius = 1000  # radius of starting ring (incremented by 1000 each circle)\n",
    "\n",
    "    i = len(nodes) - 1  # start from hidden units\n",
    "    prev_pool = pool_ids[-1]\n",
    "    while i >= 0:\n",
    "        circum = 2 * np.pi * radius\n",
    "        # number of nodes per ring\n",
    "        ring_size = int(circum / interval)\n",
    "\n",
    "        for j in range(ring_size):\n",
    "            if i < 0:\n",
    "                break\n",
    "\n",
    "            # changing pools\n",
    "            curr_pool = pool_ids[i]\n",
    "            skip = (curr_pool != prev_pool)\n",
    "            prev_pool = curr_pool\n",
    "\n",
    "            if skip:\n",
    "                # moving to a new ring if pool won't fit\n",
    "                if (j > 0) and (pool_lens[curr_pool] > (ring_size)-(j+1)):\n",
    "                    break\n",
    "\n",
    "                # else staying in current ring and moving a space\n",
    "                else:\n",
    "                    continue\n",
    "\n",
    "            # placing node\n",
    "            angle = 270 + (j * (360/ring_size))\n",
    "            x = center_coord[0] + (np.cos(np.radians(angle)) * radius)\n",
    "            y = center_coord[1] + (np.sin(np.radians(angle)) * radius)\n",
    "            pos[nodes[i]] = [x, y]\n",
    "            i -= 1\n",
    "\n",
    "        radius += 1000\n",
    "\n",
    "    return pos\n",
    "\n",
    "def run_simulation(G, pools, clicked_nodes, num_cycles, learning_rate=0.1):\n",
    "   # Adjust node relationships over time based on pool membership\n",
    "\n",
    "    G = G.copy()\n",
    "    for _ in range(num_cycles):\n",
    "        for node in clicked_nodes:\n",
    "            # Get edges connected to the selected node\n",
    "            node_edges = [e for e in G.edges(data=True) if node in e]\n",
    "            for u, v, d in node_edges:\n",
    "                if u == v:  # Skip self-loops\n",
    "                    continue\n",
    "                if pools[u] != pools[v]:  # Excitatory update (different pools)\n",
    "                    weight_update = learning_rate\n",
    "                else:  # Inhibitory update (same pool)\n",
    "                    weight_update = -learning_rate\n",
    "                \n",
    "                # Update the weight\n",
    "                new_weight = d['weight'] + weight_update\n",
    "                G[u][v]['weight'] = new_weight  # Modify the edge weight directly\n",
    "\n",
    "    return G\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 95,
   "id": "c1283d88",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-12-06T20:49:59.362331Z",
     "start_time": "2024-12-06T20:49:59.162697Z"
    }
   },
   "outputs": [],
   "source": [
    "### Plotting Logic\n",
    "\n",
    "def init_graph(df, hidden_state=None):\n",
    "    # Initialize the graph from a DataFrame.\n",
    "    df = df.copy().dropna()\n",
    "    assert len(df) > 0, f\"DataFrame currently has shape {df.shape}. Must have more than 0 non-null rows.\"\n",
    "    \n",
    "    df = df.astype(str)\n",
    "    if hidden_state is None:\n",
    "        hidden_state = df.columns[0]\n",
    "\n",
    "    pools = {}\n",
    "    for c in df.columns:\n",
    "        nodes = df[c].unique()\n",
    "        for n in nodes:\n",
    "            pools[f\"{c}: {n}\"] = c\n",
    "\n",
    "    for hidden_node in df[hidden_state].unique():\n",
    "        pools[f\"hidden: {hidden_node}\"] = 'hidden'\n",
    "    \n",
    "    nodes = pools.keys()\n",
    "    edges = []\n",
    "    hidden_nodes = [k for k, v in pools.items() if v == 'hidden']\n",
    "\n",
    "    for c in df.columns:\n",
    "        pool_nodes = [k for k, v in pools.items() if v == c]\n",
    "        for n in pool_nodes:\n",
    "            hidden_connections = df[df[c] == n.split(': ')[1]][hidden_state].unique()\n",
    "            edges.extend([(f'hidden: {h}', n, 0) for h in hidden_connections])\n",
    "        edges.extend([(u, v, 0) for u, v in combinations(pool_nodes, 2)])\n",
    "\n",
    "    edges.extend([(u, v, 0) for u, v in combinations(hidden_nodes, 2)])\n",
    "\n",
    "    G = nx.Graph()\n",
    "    G.add_nodes_from(nodes)\n",
    "    for u, v, weight in edges:\n",
    "        G.add_edge(u, v, weight=weight)\n",
    "\n",
    "    pos = position_nodes(pools)\n",
    "    return pos, pools, G\n",
    "\n",
    "\n",
    "def serialize_graph(G):\n",
    "    # Convert a NetworkX graph to a JSON-serializable format.\n",
    "    return nx.node_link_data(G)\n",
    "\n",
    "\n",
    "def deserialize_graph(data):\n",
    "    # Convert JSON-serialized graph data back to a NetworkX graph.\n",
    "    return nx.node_link_graph(data)\n",
    "\n",
    "\n",
    "def free_local_port(port='8050'):\n",
    "    # Free a local port if necessary (to run Dash app).\n",
    "    port_process = subprocess.run(\n",
    "        [\"lsof\", \"-i\", f\":{port}\"], \n",
    "        stdout=subprocess.PIPE, \n",
    "        stderr=subprocess.PIPE, \n",
    "        text=True\n",
    "    )\n",
    "    if len(port_process.stdout) > 1:\n",
    "        text = port_process.stdout\n",
    "        print(text)\n",
    "        info = {}\n",
    "        lines = [l.split() for l in text.split('\\n')]\n",
    "        for i in range(len(lines[0])):\n",
    "            field, data = lines[0][i], lines[1][i]\n",
    "            info[field] = data\n",
    "        \n",
    "        if info.get('PID', None) is not None:\n",
    "            subprocess.run([\"kill\", \"-9\", info['PID']])\n",
    "\n",
    "\n",
    "def find_free_port():\n",
    "    # Find a free port to use for the Dash app.\n",
    "    with socket.socket() as s:\n",
    "        s.bind(('', 0))            \n",
    "        return s.getsockname()[1]\n",
    "\n",
    "def create_plot(pos, pools, G, hover_node=None):\n",
    "    # creating figure\n",
    "    fig = go.Figure()\n",
    "    \n",
    "    # getting node sizes, node colors, connection linewidths\n",
    "    activations, rest_act = get_activation(G)\n",
    "    sizes = activation_to_size(activations)\n",
    "    colors = [col_pal[list(set(pools.values())).index(pools[n])] for n in G.nodes()]\n",
    "    linewidths = connection_to_lw(G.edges(data=True))\n",
    "    \n",
    "    # plotting non-zero connections\n",
    "    for edge_group, line_width in zip(G.edges(data=True), linewidths):\n",
    "        u, v, d = edge_group\n",
    "        # skipping 0 weight\n",
    "        if d['weight'] == 0:\n",
    "            continue\n",
    "        # skipping hover_node connections\n",
    "        if (hover_node is not None and hover_node in {u,v}):\n",
    "            continue\n",
    "        x = [pos[u][0], pos[v][0], None]\n",
    "        y = [pos[u][1], pos[v][1], None]\n",
    "        \n",
    "        # line color (light red and light blue)\n",
    "        line_color = '#8181ff' if pools[u] != pools[v] else '#ff8181'\n",
    "        \n",
    "        fig.add_trace(go.Scatter(\n",
    "                    x=x, y=y, \n",
    "                    line=dict(width=line_width, color=line_color),\n",
    "                    hoverinfo='none',\n",
    "                    mode='lines',\n",
    "                    showlegend=False)\n",
    "                  )\n",
    "    \n",
    "    # setting up node outline colors\n",
    "    outline_colors = colors.copy()\n",
    "    \n",
    "    # plotting hover node if needed\n",
    "    if hover_node is not None:\n",
    "        hidden_ind = list(G.nodes()).index(hover_node)\n",
    "        for edge_group, line_width in zip(G.edges(data=True), linewidths):\n",
    "            u,v,d=edge_group\n",
    "            x, y = [], []\n",
    "            if hover_node in {u,v}:\n",
    "                x += [pos[u][0], pos[v][0], None]\n",
    "                y += [pos[u][1], pos[v][1], None]\n",
    "            \n",
    "                # connection line color\n",
    "                line_color = 'blue' if pools[u] != pools[v] else 'red'\n",
    "            \n",
    "                # node outline colors\n",
    "                adjust_ind = list(G.nodes()).index(u) if hover_node != u else list(G.nodes()).index(v)\n",
    "                outline_colors[adjust_ind] = line_color\n",
    "                outline_colors[hidden_ind] = 'black' # selected node line color\n",
    "                colors[hidden_ind] = 'yellow' # selected node fill color\n",
    "            \n",
    "                fig.add_trace(go.Scatter(\n",
    "                            x=x, y=y,\n",
    "                            line=dict(width=line_width, color=line_color),\n",
    "                            hoverinfo='none',\n",
    "                            mode='lines',\n",
    "                            showlegend=False,)\n",
    "                          )\n",
    "    \n",
    "    # Adding Nodes\n",
    "    node_trace = go.Scatter(\n",
    "        x=[pos[n][0] for n in G.nodes()],\n",
    "        y=[pos[n][1] for n in G.nodes()],\n",
    "        text=[f\"{n.split(': ')[1]}\" for n in G.nodes()],\n",
    "        marker=dict(size=sizes, \n",
    "                    color=colors,\n",
    "                    line=dict(width=2, color=outline_colors),\n",
    "                    opacity=1.0,\n",
    "                   ),\n",
    "        hoverinfo=\"text\",\n",
    "        hovertext=[f\"Activation: {activations[n]}<br>Net Input: {activations[n]-rest_act}\" for n in G.nodes()],\n",
    "        mode=\"markers+text\",\n",
    "        showlegend=False)\n",
    "    fig.add_trace(node_trace)\n",
    "    \n",
    "    # Adding Legend Labels (dummy traces)\n",
    "    fig.add_trace(go.Scatter(\n",
    "        x=[None], y=[None],\n",
    "        line=dict(width=2, color=\"blue\"),\n",
    "        mode=\"lines\",\n",
    "        name=\"excitatory\",\n",
    "        showlegend=True\n",
    "    ))\n",
    "    fig.add_trace(go.Scatter(\n",
    "        x=[None], y=[None],\n",
    "        line=dict(width=2, color=\"red\"),\n",
    "        mode=\"lines\",\n",
    "        name=\"inhibitory\",\n",
    "        showlegend=True\n",
    "    ))\n",
    "    for i in range(len(list(set(pools.values())))):\n",
    "        fig.add_trace(go.Scatter(\n",
    "            x=[None], y=[None],\n",
    "            marker=dict(size=20,color=col_pal[i]),\n",
    "            mode=\"markers\",\n",
    "            name=list(set(pools.values()))[i],\n",
    "            showlegend=True\n",
    "        ))\n",
    "    \n",
    "    # removing grid and axes\n",
    "    fig.update_layout(\n",
    "        showlegend=True,\n",
    "        hovermode=\"closest\",\n",
    "        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n",
    "        yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n",
    "        width=700,\n",
    "        height=675,\n",
    "        plot_bgcolor=\"white\",\n",
    "        margin=dict(t=30, l=20, r=20),\n",
    "        title = \"Interactive Activation and Competition Network\"\n",
    "    )\n",
    "\n",
    "    return fig\n",
    "\n",
    "\n",
    "def plot(df, hidden_state=None):\n",
    "    # Take in DataFrame and creates visualization\n",
    "    pos, pools, G = init_graph(df, hidden_state)\n",
    "    pos_map = {tuple(v):k for k,v in pos.items()}\n",
    "    \n",
    "    # Setting up Dash app\n",
    "    app = dash.Dash(__name__)\n",
    "\n",
    "    # App layout\n",
    "    app.layout = html.Div(\n",
    "        style={'display': 'flex', 'height':'90vh'},\n",
    "        children=[\n",
    "            # control panel (left)\n",
    "            html.Div(\n",
    "                style={\n",
    "                    'width': '115px',\n",
    "                    'padding': '10px',\n",
    "                    'background-color': '#f8f9fa',\n",
    "                    'box-shadow': '2px 0 5px rgba(0, 0, 0, 0.1)',\n",
    "                    'flex':'none', # fixed size \n",
    "                },\n",
    "                children=[\n",
    "                    html.Button( # reset button \n",
    "                        id = 'reset-button',\n",
    "                        children = 'Reset Network',\n",
    "                        style = {\n",
    "                            'background-color': 'skyblue',\n",
    "                            'color': 'white',\n",
    "                            'border': 'none',\n",
    "                            'borderRadius': '5px',\n",
    "                            'padding': '5px 5px',\n",
    "                            'cursor': 'pointer',\n",
    "                            'margin-bottom': '10px'\n",
    "                        }\n",
    "                    ),\n",
    "                    html.Div( # box for slider output\n",
    "                        id='slider-output',\n",
    "                        style={\n",
    "                            'margin-bottom': '10px',\n",
    "                            'font-size': '14px',\n",
    "                            'text-align': 'center',\n",
    "                        }\n",
    "                    ),\n",
    "                    dcc.Slider(0,1000, # slider for simulation\n",
    "                       value=0,\n",
    "                       id='num-cycles',\n",
    "                       vertical=True,\n",
    "                    ),\n",
    "                    html.Button( # run simulation button\n",
    "                        id = 'run-simulation',\n",
    "                        children = 'Run Simulation',\n",
    "                        style = {\n",
    "                            'background-color': '#FA5F55',\n",
    "                            'color': 'white',\n",
    "                            'border': 'none',\n",
    "                            'borderRadius': '5px',\n",
    "                            'padding': '5px 5px',\n",
    "                            'cursor': 'pointer',\n",
    "                            'margin-top': '10px',\n",
    "                        }\n",
    "                    ),\n",
    "                    dcc.Store(\n",
    "                        id = 'selected-nodes', # place to store selected nodes\n",
    "                        data = []\n",
    "                    ),\n",
    "                ]\n",
    "            ),\n",
    "            # network (right)\n",
    "            html.Div(\n",
    "                style={'flex':'1', # will resize based on available space\n",
    "                       'padding': '10px',\n",
    "                },\n",
    "                children=[\n",
    "                    dcc.Graph(\n",
    "                        id = 'network-graph', # figure\n",
    "                        figure = create_plot(pos, pools, G),\n",
    "                    ),\n",
    "                    dcc.Store(\n",
    "                        id = 'graph-state', # store graph\n",
    "                        data = serialize_graph(G)\n",
    "                    ),\n",
    "                ]\n",
    "            )\n",
    "        ]\n",
    "    )\n",
    "\n",
    "    @app.callback(\n",
    "         [Output('network-graph', 'figure'),   # Output for figure\n",
    "          Output('graph-state', 'data'),       # Output for graph\n",
    "          Output('selected-nodes', 'data'),    # Output for node storage\n",
    "          Output('slider-output', 'children'), # Output for slider container\n",
    "          Output('num-cycles', 'value')],      # Output for slider value\n",
    "         [Input('network-graph', 'hoverData'), # Input for hover event\n",
    "          Input('network-graph', 'clickData'), # Input for click event\n",
    "          Input('reset-button', 'n_clicks'),   # Input for reset button click\n",
    "          Input('run-simulation', 'n_clicks'), # Input for simulation button click\n",
    "          Input('num-cycles', 'value')],       # Input for slider\n",
    "         [State('selected-nodes', 'data'),     # State of selected-nodes\n",
    "          State('network-graph', 'figure'),    # State of figure\n",
    "          State('graph-state', 'data')]        # State of Graph \n",
    "    )\n",
    "    def fig_update(hoverData,\n",
    "                   clickData,\n",
    "                   n_clicks_reset, \n",
    "                   n_clicks_sim, \n",
    "                   value, \n",
    "                   selected_data, \n",
    "                   figure,\n",
    "                   graph_data):\n",
    "        '''\n",
    "        returns: fig, clicked_nodes, slider_text, slider_value\n",
    "        '''\n",
    "        \n",
    "        G = deserialize_graph(graph_data)\n",
    "        \n",
    "        fig = go.Figure(figure)\n",
    "        event = dash.callback_context\n",
    "        trig_event = event.triggered[0]['prop_id']\n",
    "    \n",
    "        if 'network-graph' in trig_event:\n",
    "            # Identify selected node (using location in case node 'text' is not unique)\n",
    "            selected_node = pos_map[(hoverData['points'][0]['x'], hoverData['points'][0]['y'])]\n",
    "            node_ind = list(G.nodes()).index(selected_node)\n",
    "    \n",
    "        if trig_event == 'network-graph.hoverData' and hoverData and 'points' in hoverData:\n",
    "            fig = create_plot(pos, pools, G, hover_node=selected_node)\n",
    "    \n",
    "        if trig_event == 'network-graph.clickData' and clickData and 'points' in clickData:\n",
    "            # toggle back to normal if already selected\n",
    "            if selected_node in selected_data:\n",
    "                selected_data.remove(selected_node)\n",
    "            \n",
    "                # resetting color back to original color\n",
    "                orig_colors = [col_pal[list(set(pools.values())).index(pools[n])] for n in G.nodes()]\n",
    "                for trace in fig.data:\n",
    "                    if 'marker' in trace and 'markers+text' in trace.mode:\n",
    "                        curr_colors = list(trace.marker.color)\n",
    "                        curr_colors[node_ind] = 'yellow' #orig_colors[node_ind]\n",
    "                        trace.marker.color = curr_colors\n",
    "                    \n",
    "            # else add node to selected-nodes\n",
    "            else:\n",
    "                selected_data.append(selected_node)\n",
    "    \n",
    "        if trig_event == 'reset-button.n_clicks':\n",
    "            # resetting all Graph connections to 0\n",
    "            edges = [e for e in G.edges(data=True)]\n",
    "            for u,v,w in edges:\n",
    "                G.remove_edges_from([(u,v,w)])\n",
    "                G.add_edge(u, v, weight=0)\n",
    "            \n",
    "            # creating default figure\n",
    "            fig = create_plot(pos, pools, G)\n",
    "            \n",
    "            # emptying clicked nodes\n",
    "            selected_data = []\n",
    "            \n",
    "            # resetting slider value\n",
    "            value = 0\n",
    "        \n",
    "        if trig_event == 'run-simulation.n_clicks':\n",
    "            G = run_simulation(G, pools, \n",
    "                                    clicked_nodes = selected_data, \n",
    "                                    num_cycles = value)\n",
    "            fig = create_plot(pos, pools, G)\n",
    "        \n",
    "        for clicked_node in selected_data:\n",
    "            clicked_ind = list(G.nodes()).index(clicked_node)\n",
    "        \n",
    "            for trace in fig.data:\n",
    "                if 'marker' in trace and 'markers+text' in trace.mode:\n",
    "                    curr_colors = list(trace.marker.color)\n",
    "                    curr_colors[clicked_ind] = 'lightcyan'\n",
    "                    trace.marker.color = curr_colors\n",
    "    \n",
    "        slider_text = f\"Number of Update Cycles: {value}\"\n",
    "        graph_data = serialize_graph(G)\n",
    "    \n",
    "        return fig, graph_data, selected_data, slider_text, value\n",
    "    \n",
    "    try:\n",
    "        port = find_free_port()\n",
    "    except:\n",
    "        print(\"No ports are available. The below process is running on local port 8050:\\n\")\n",
    "        local_port = subprocess.run([\"lsof\", \"-i\", f\":8050\"], \n",
    "                                  stdout=subprocess.PIPE, \n",
    "                                  stderr=subprocess.PIPE, \n",
    "                                  text=True)\n",
    "        print(local_port.stdout)\n",
    "        user_in = input(\"\\nWould you like to kill the above process to make space? [y/n] \")\n",
    "        if user_in.strip().lower() not in ['y', 'yes']:\n",
    "            print('Aborting Visualization...')\n",
    "            return\n",
    "        print('Freeing port 8050...')\n",
    "        port = '8050'\n",
    "        free_local_port()\n",
    "    \n",
    "    app.run(port=port)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4f9ef59d",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-12-06T20:30:05.258021Z",
     "start_time": "2024-12-06T20:30:05.252259Z"
    }
   },
   "source": [
    "# Usage"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 96,
   "id": "839f5891",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-12-06T20:50:02.154145Z",
     "start_time": "2024-12-06T20:50:02.093063Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "\n",
       "        <iframe\n",
       "            width=\"100%\"\n",
       "            height=\"650\"\n",
       "            src=\"http://127.0.0.1:59302/\"\n",
       "            frameborder=\"0\"\n",
       "            allowfullscreen\n",
       "            \n",
       "        ></iframe>\n",
       "        "
      ],
      "text/plain": [
       "<IPython.lib.display.IFrame at 0x1407a43d0>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "plot(pd.read_csv('data/jets_sharks.csv'))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 99,
   "id": "4e401b4e",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-12-06T20:51:25.771020Z",
     "start_time": "2024-12-06T20:51:25.752395Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>Character</th>\n",
       "      <th>House</th>\n",
       "      <th>Age_Group</th>\n",
       "      <th>Allegiance</th>\n",
       "      <th>Role</th>\n",
       "      <th>Specialty</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>Eddard</td>\n",
       "      <td>Stark</td>\n",
       "      <td>40's</td>\n",
       "      <td>Kingdom of the North</td>\n",
       "      <td>Warden</td>\n",
       "      <td>Leadership</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>Catelyn</td>\n",
       "      <td>Stark</td>\n",
       "      <td>40's</td>\n",
       "      <td>Kingdom of the North</td>\n",
       "      <td>Advisor</td>\n",
       "      <td>Strategy</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>Robb</td>\n",
       "      <td>Stark</td>\n",
       "      <td>20's</td>\n",
       "      <td>Kingdom of the North</td>\n",
       "      <td>Commander</td>\n",
       "      <td>Battle</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>Arya</td>\n",
       "      <td>Stark</td>\n",
       "      <td>20's</td>\n",
       "      <td>Kingdom of the North</td>\n",
       "      <td>Assassin</td>\n",
       "      <td>Stealth</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>Sansa</td>\n",
       "      <td>Stark</td>\n",
       "      <td>20's</td>\n",
       "      <td>Kingdom of the North</td>\n",
       "      <td>Princess</td>\n",
       "      <td>Politics</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>5</th>\n",
       "      <td>Jon</td>\n",
       "      <td>Stark</td>\n",
       "      <td>20's</td>\n",
       "      <td>Night's Watch</td>\n",
       "      <td>Commander</td>\n",
       "      <td>Honor</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>6</th>\n",
       "      <td>Daenerys</td>\n",
       "      <td>Targaryen</td>\n",
       "      <td>30's</td>\n",
       "      <td>Targaryen Empire</td>\n",
       "      <td>Queen</td>\n",
       "      <td>Dragon Mastery</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>7</th>\n",
       "      <td>Tyrion</td>\n",
       "      <td>Lannister</td>\n",
       "      <td>30's</td>\n",
       "      <td>Targaryen Empire</td>\n",
       "      <td>Advisor</td>\n",
       "      <td>Negotiation</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>8</th>\n",
       "      <td>Cersei</td>\n",
       "      <td>Lannister</td>\n",
       "      <td>40's</td>\n",
       "      <td>Lannister Family</td>\n",
       "      <td>Queen</td>\n",
       "      <td>Manipulation</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>9</th>\n",
       "      <td>Jaime</td>\n",
       "      <td>Lannister</td>\n",
       "      <td>30's</td>\n",
       "      <td>Lannister Family</td>\n",
       "      <td>Commander</td>\n",
       "      <td>Swordsmanship</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>10</th>\n",
       "      <td>Tywin</td>\n",
       "      <td>Lannister</td>\n",
       "      <td>50's</td>\n",
       "      <td>Lannister Family</td>\n",
       "      <td>Patriarch</td>\n",
       "      <td>Strategy</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>11</th>\n",
       "      <td>Petyr</td>\n",
       "      <td>Independent</td>\n",
       "      <td>30's</td>\n",
       "      <td>Schemer</td>\n",
       "      <td>Schemer</td>\n",
       "      <td>Deception</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>12</th>\n",
       "      <td>Varys</td>\n",
       "      <td>Independent</td>\n",
       "      <td>40's</td>\n",
       "      <td>Schemer</td>\n",
       "      <td>Spy</td>\n",
       "      <td>Information</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>13</th>\n",
       "      <td>Jorah</td>\n",
       "      <td>Targaryen</td>\n",
       "      <td>40's</td>\n",
       "      <td>Targaryen Empire</td>\n",
       "      <td>Advisor</td>\n",
       "      <td>Loyalty</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "   Character        House Age_Group            Allegiance       Role  \\\n",
       "0     Eddard        Stark      40's  Kingdom of the North     Warden   \n",
       "1    Catelyn        Stark      40's  Kingdom of the North    Advisor   \n",
       "2       Robb        Stark      20's  Kingdom of the North  Commander   \n",
       "3       Arya        Stark      20's  Kingdom of the North   Assassin   \n",
       "4      Sansa        Stark      20's  Kingdom of the North   Princess   \n",
       "5        Jon        Stark      20's         Night's Watch  Commander   \n",
       "6   Daenerys    Targaryen      30's      Targaryen Empire      Queen   \n",
       "7     Tyrion    Lannister      30's      Targaryen Empire    Advisor   \n",
       "8     Cersei    Lannister      40's      Lannister Family      Queen   \n",
       "9      Jaime    Lannister      30's      Lannister Family  Commander   \n",
       "10     Tywin    Lannister      50's      Lannister Family  Patriarch   \n",
       "11     Petyr  Independent      30's               Schemer    Schemer   \n",
       "12     Varys  Independent      40's               Schemer        Spy   \n",
       "13     Jorah    Targaryen      40's      Targaryen Empire    Advisor   \n",
       "\n",
       "         Specialty  \n",
       "0       Leadership  \n",
       "1         Strategy  \n",
       "2           Battle  \n",
       "3          Stealth  \n",
       "4         Politics  \n",
       "5            Honor  \n",
       "6   Dragon Mastery  \n",
       "7      Negotiation  \n",
       "8     Manipulation  \n",
       "9    Swordsmanship  \n",
       "10        Strategy  \n",
       "11       Deception  \n",
       "12     Information  \n",
       "13         Loyalty  "
      ]
     },
     "execution_count": 99,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# GoT csv I created, see below\n",
    "\n",
    "pd.read_csv('game_of_thrones_subset.csv')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 100,
   "id": "25ba6261",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2024-12-06T20:51:26.292955Z",
     "start_time": "2024-12-06T20:51:26.239833Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "\n",
       "        <iframe\n",
       "            width=\"100%\"\n",
       "            height=\"650\"\n",
       "            src=\"http://127.0.0.1:59410/\"\n",
       "            frameborder=\"0\"\n",
       "            allowfullscreen\n",
       "            \n",
       "        ></iframe>\n",
       "        "
      ],
      "text/plain": [
       "<IPython.lib.display.IFrame at 0x14185d090>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "plot(pd.read_csv('game_of_thrones_subset.csv'))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a171a4c9",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ac3276db",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
